public class Sort {
    /*算法排序的稳定性
     *腾讯校招2016笔试题曾考过
     *定义：如果Ai = Aj,排序前Ai在Aj之前，排序后Ai还在Aj之前，则称这种排序算法是稳定的。
     */
    ////////////////////////////冒泡排序算法////////////////////////////////////////////
    //主要思路重复地走访要排序的数列，一次比较相邻两个元素，如果他们的顺序错误就把他们交换过来
    //分类--------------内部比较排序
    //数据结构----------数组
    //最差时间复杂度----O(n^2)
    //最优时间复杂度----O(n),使用一个标志位来判断是否已经排序好的
    //平均时间复杂度----O(n^2)
    //辅助空间----------O(1)
    //稳定性------------稳定
    public static void BubbleSort(int[] a){
        boolean flag = true; //标志位，用于判断是否已经排序好
        for (int i = 0; i < a.length-1; i++){
            for (int j = 0; j < a.length-i-1; j++){
                if(a[j] > a[j+1]){  //如果判断条件改为a[j] >= a[j+1]，则为不稳定排序算法
                    Swap(a, j, j+1);
                    flag = false;
                }
            }
            if(flag) break;  //如果元素已经排序好就直接退出，最好的情况是只循环一次就退出
            flag = true;
        }
    }
    ////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////冒泡排序算法的改进：鸡尾酒排序/////////////////////////////////////////
    //鸡尾酒排序即双向的冒泡排序，是冒泡排序的轻微变形。
    //主要思路是对于一组无规律排放的数字，先找到最大的数字放到最后一位，在反向找到最小的数字放到第一位。然后再找第二大的数字放到倒数第二位，再找第二小的数字放到第二位。
    //以此类推，直到所有数字有序排列。
    //分类--------------内部比较排序
    //数据结构----------数组
    //最差时间复杂度----O(n^2)
    //最优时间复杂度----0(n)
    //平均时间复杂度----O(n^2)
    //辅助空间----------O(1)
    //稳定性------------稳定
    public static void CocktailSort (int[] a){
        //初始化边界
        int left = 0;
        int right = a.length-1;
        while (left < right){
            for (int i = left; i < right; i++){ //前半趟，将最大元素放到后面
                if(a[i] > a[i+1]){
                    Swap(a,i,i+1);
                }
            }
            right--;
            for (int i = right; i > left; i--){ //后半趟，将最小元素放到前面
                if(a[i-1] > a[i]){
                    Swap(a,i-1,i);
                }
            }
            left++;
        }
    }
    ////////////////////////////////////////////////////////////////////////////////////////
    ////////////选择排序////////////////////////////////////////////////////////////////////
    //初始时找到最小的元素，放到数组起始位置，然后从剩余未排序元素中寻找最小元素，放到已排序序列的末尾
    //以此类推，知道所有元素有序排列。
    //分类--------------内部比较排序
    //数据结构----------数组
    //最差时间复杂度----O(n^2)
    //最优时间复杂度----O(n^2)
    //平均时间复杂度----O(n^2)
    //辅助空间----------O(1)
    //稳定性------------不稳定
    public static void SelectionSort(int[] a){
        for (int i = 0; i < a.length-1; i++){
            int min = i; //i为已排序列的末尾
            for (int j = i+1; j < a.length; j++){ //未排序列
                if(a[j] < a[min]){
                    min = j; //记录当前最小元素位置
                }
            }
            if(min != i){
                Swap(a, min, i); //交换时可能会破坏相对顺序，所以是不稳定算法
                                 //例如 3,4,3,1 第一个3和1交换时，原序列的两个3的相对顺序就改变了
            }
        }
    }
    //交换数组中的两个值
    private static void Swap(int[] a, int i, int j){
        int temp = a[i];
        a[i] = a[j];
        a[j] = temp;
    }
}
