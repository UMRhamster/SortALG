import java.util.Arrays;

public class Sort {
    /*算法排序的稳定性
     *腾讯校招2016笔试题曾考过
     *定义：如果Ai = Aj,排序前Ai在Aj之前，排序后Ai还在Aj之前，则称这种排序算法是稳定的。
     */
    ////////////////////////////冒泡排序算法////////////////////////////////////////////
    //主要思路重复地走访要排序的数列，一次比较相邻两个元素，如果他们的顺序错误就把他们交换过来
    //分类--------------内部比较排序
    //数据结构----------数组
    //最差时间复杂度----O(n^2)
    //最优时间复杂度----O(n),使用一个标志位来判断是否已经排序好的
    //平均时间复杂度----O(n^2)
    //辅助空间----------O(1)
    //稳定性------------稳定
    public static void BubbleSort(int[] a){
        boolean flag = true; //标志位，用于判断是否已经排序好
        for (int i = 0; i < a.length-1; i++){
            for (int j = 0; j < a.length-i-1; j++){
                if(a[j] > a[j+1]){  //如果判断条件改为a[j] >= a[j+1]，则为不稳定排序算法
                    Swap(a, j, j+1);
                    flag = false;
                }
            }
            if(flag) break;  //如果元素已经排序好就直接退出，最好的情况是只循环一次就退出
            flag = true;
        }
    }
    ////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////冒泡排序算法的改进：鸡尾酒排序/////////////////////////////////////////
    //鸡尾酒排序即双向的冒泡排序，是冒泡排序的轻微变形。
    //主要思路是对于一组无规律排放的数字，先找到最大的数字放到最后一位，在反向找到最小的数字放到第一位。然后再找第二大的数字放到倒数第二位，再找第二小的数字放到第二位。
    //以此类推，直到所有数字有序排列。
    //分类--------------内部比较排序
    //数据结构----------数组
    //最差时间复杂度----O(n^2)
    //最优时间复杂度----0(n)
    //平均时间复杂度----O(n^2)
    //辅助空间----------O(1)
    //稳定性------------稳定
    public static void CocktailSort (int[] a){
        //初始化边界
        int left = 0;
        int right = a.length-1;
        while (left < right){
            for (int i = left; i < right; i++){ //前半趟，将最大元素放到后面
                if(a[i] > a[i+1]){
                    Swap(a,i,i+1);
                }
            }
            right--;
            for (int i = right; i > left; i--){ //后半趟，将最小元素放到前面
                if(a[i-1] > a[i]){
                    Swap(a,i-1,i);
                }
            }
            left++;
        }
    }
    ////////////////////////////////////////////////////////////////////////////////////////
    ////////////选择排序////////////////////////////////////////////////////////////////////
    //初始时找到最小的元素，放到数组起始位置，然后从剩余未排序元素中寻找最小元素，放到已排序序列的末尾
    //以此类推，知道所有元素有序排列。
    //分类--------------内部比较排序
    //数据结构----------数组
    //最差时间复杂度----O(n^2)
    //最优时间复杂度----O(n^2)
    //平均时间复杂度----O(n^2)
    //辅助空间----------O(1)
    //稳定性------------不稳定
    public static void SelectionSort(int[] a){
        for (int i = 0; i < a.length-1; i++){
            int min = i; //i为已排序列的末尾
            for (int j = i+1; j < a.length; j++){ //未排序列
                if(a[j] < a[min]){
                    min = j; //记录当前最小元素位置
                }
            }
            if(min != i){
                Swap(a, min, i); //交换时可能会破坏相对顺序，所以是不稳定算法
                                 //例如 3,4,3,1 第一个3和1交换时，原序列的两个3的相对顺序就改变了
            }
        }
    }
    ////////////////////////////////////////////////////////////////////////////////////////
    /////////////插入排序///////////////////////////////////////////////////////////////////
    //分类--------------内部比较排序
    //数据结构----------数组
    //最差时间复杂度----O(n^2)
    //最优时间复杂度----O(n)
    //平均时间复杂度----O(n^2)
    //辅助空间----------O(1)
    //稳定性------------稳定
    public static void insertionSort(int[] a){
        for (int i = 1; i < a.length; i++){
            int get = a[i];
            int j = i-1;
            while (j >= 0 && a[j] > get){ //从右向左比较
                a[j+1] = a[j]; //后移一位
                j--;
            }
            a[j+1] = get;
        }
    }
    ////////////////////////////////////////////////////////////////////////////////////////
    ////////////插入排序的改进：二分插入排序//////////////////////////////////////////////////
    //如果插入排序的比较操作的代价比交换操作大的话，可以使用二分查找法来减少比较操作的次数。
    //因为在新插入值左边的序列已经是排序好的，所以可以采用二分法。
    //分类--------------内部比较排序
    //数据结构----------数组
    //最差时间复杂度----O(n^2)
    //最优时间复杂度----O(nlogn)
    //平均时间复杂度----O(n^2)
    //辅助空间----------O(1)
    //稳定性------------稳定
    public static void InsertionSortDichotomy(int[] a){
        for (int i = 1; i<a.length; i++){
            int get = a[i];
            int left = 0;
            int right = i-1;
            while (left <= right){ //采用二分法定位插入位置
                int mid = (left + right) / 2;
                if(a[mid] > get){
                    right = mid - 1;
                }else {
                    left = mid + 1;
                }
            }
            for (int j = i - 1; j >= left; j--){ //将插入位置右边的牌整体向右移动一位
                a[j+1] = a[j];
            }
            a[left] = get; //插入
        }
    }
    ////////////////////////////////////////////////////////////////////////////////////////
    /////////////////插入排序的更高效排序：希尔排序///////////////////////////////////////////
    //分类--------------内部比较排序
    //数据结构----------数组
    //最差时间复杂度----根据步长序列的不同而不同，已知最好的为O(n(logn)^2)
    //最优时间复杂度----O(n)
    //平均时间复杂度----根据步长序列的不同而不同
    //辅助空间----------O(1)
    //稳定性------------不稳定
    public static void ShellSort(int[] a){
        int h = 0;
        while (h <= a.length){
            h = 3 * h +1;
        }
        while (h >= 1){
            for (int i = h; i < a.length; i++){
                int j = i - h;
                int get = a[i];
                while (j >= 0 && a[j] >get){
                    a[j+h] = a[j];
                    j = j-h;
                }
                a[j+h] = get;
            }
            h = (h - 1) / 3;
        }
    }
    //////////////////////////////////////////////////////////////////////////////////////////
    //////////////归并排序////////////////////////////////////////////////////////////////////
    //分类--------------内部比较排序
    //数据结构----------数组
    //最差时间复杂度----O(nlogn)
    //最优时间复杂度----O(nlogn)
    //平均时间复杂度----O(nlogn)
    //辅助空间----------O(n)
    //稳定性------------稳定
    public static void MergeSortIteration(int[] a){   //非递归
        int left, mid, right;
        for (int i = 1; i < a.length; i *= 2){
            left = 0;
            while (left + i < a.length){
                mid = left + i - 1;
                right = mid + i < a.length ? mid + i : a.length - 1;
                Merge(a, left, mid, right);
                left = right + 1;               // 前一个子数组索引向后移动
            }
        }
    }
    public static void MergeSortRecursion(int[] a, int left, int right){
        if(left == right)
            return;
        int mid = (left + right) / 2;
        MergeSortRecursion(a,left,mid);
        MergeSortRecursion(a,mid+1,right);
        Merge(a,left,mid,right);

    }
    ////////////////////////////////////////////////////////////////////////////////////////
    ///////////快速排序/////////////////////////////////////////////////////////////////////
    //分类--------------内部比较排序
    //数据结构----------数组
    //最差时间复杂度----O(n^2)
    //最优时间复杂度----O(nlogn)
    //平均时间复杂度----O(nlogn)
    //辅助空间----------一般为O(logn), 最差为O(n)
    //稳定性------------不稳定
    public static void QuickSort(int A[], int left, int right)
    {
        if (left >= right)
            return;
        int pivot_index = Partition(A, left, right); // 基准的索引
        QuickSort(A, left, pivot_index - 1);
        QuickSort(A, pivot_index + 1, right);
    }
    public static int Partition(int A[], int left, int right)  // 划分函数
    {
        int pivot = A[right];               // 这里每次都选择最后一个元素作为基准
        int tail = left - 1;                // tail为小于基准的子数组最后一个元素的索引
        for (int i = left; i < right; i++)  // 遍历基准以外的其他元素
        {
            if (A[i] <= pivot)              // 把小于等于基准的元素放到前一个子数组末尾
            {
                Swap(A, ++tail, i);
            }
        }
        Swap(A, tail + 1, right);           // 最后把基准放到前一个子数组的后边，剩下的子数组既是大于基准的子数组
        // 该操作很有可能把后面元素的稳定性打乱，所以快速排序是不稳定的排序算法
        return tail + 1;                    // 返回基准的索引
    }
    ///////////////////////////////////////////////////////////////////////////////////////



    //
    //合并已排好序的数组
    public static void Merge(int[] a, int left, int mid, int right){
        int len = right - left + 1;
        int[] temp = new int[len];       // 辅助空间O(n)
        int index = 0;
        int i = left;                   // 前一数组的起始元素
        int j = mid + 1;                // 后一数组的起始元素
        while (i <= mid && j <= right)
        {
            temp[index++] = a[i] <= a[j] ? a[i++] : a[j++];  // 带等号保证归并排序的稳定性
        }
        while (i <= mid)
        {
            temp[index++] = a[i++];
        }
        while (j <= right)
        {
            temp[index++] = a[j++];
        }
        for (int k = 0; k < len; k++)
        {
            a[left++] = temp[k];
        }
    }
    //交换数组中的两个值
    private static void Swap(int[] a, int i, int j){
        int temp = a[i];
        a[i] = a[j];
        a[j] = temp;
    }
}
